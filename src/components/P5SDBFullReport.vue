<template>
  <div id="content">
    <h3>Show Perl5 CoreSmoke testreport {{ reportId }}</h3>
  </div>
<div v-if="isLoading" class="spinner" />
<div v-if="!httpError && !isLoading">
<button
 v-if="hasLength(rd.out_file)"
 style="margin: 1rem"
 @click="openFile('out_file', reportId)">Show outfile</button>
<button
 v-if="hasLength(rd.log_file)"
 style="margin: 1rem"
 @click="openFile('log_file', reportId)">Show logfile</button>
<div class="show-report">
<pre>
Automated smoke report for branch {{ rd.smoke_branch }} {{ rd.perl_id }} patch {{ rd.git_id }} {{ rd.git_describe }}.
{{ rd.hostname }}: {{rd.cpu_description}} ({{ rd.architecture }}/{{ rd.cpu_count }} cpus)
    on        {{ rd.osname }} {{rd.osversion}}
<span v-for="(cCompiler, idx) in rd.c_compilers" :key="idx">    using     {{ cCompiler.cc }} version {{ cCompiler.ccversion }} (*{{ idx+1 }})</span>
    smoketime {{ rd.duration_in_hhmm }} (average {{ rd.average_in_hhmm }})

Summary: <span :class="summaryClass(rd.summary)">{{ rd.summary }}</span>

O = OK  F = Failure(s), extended report at the bottom
X = Failure(s) under TEST but not under harness
? = still running or test results not (yet) available
Build failures during:       - = unknown or N/A
c = Configure, m = make, M = make (after miniperl), t = make test-prep

{{ rd.git_describe }}
----------------------- ----------------------------------------------------
{{ rd.matrix }}

<span v-if="rd.harness_only === 1">
Testsuite was run only with 'harness'</span>
<span v-if="hasLength(rd.applied_patches)">
Applied patches:
    {{ rd.applied_patches }}</span>
<span v-if="hasLength(rd.skipped_tests)">
Skipped tests:
    {{ rd.skipped_tests }}</span>
<span v-else>
Skipped tests:
    None.</span>

Test failures:<span v-if="!hasLength(rd.test_failures)">
    None.</span><span v-for="(failure, idx) in rd.test_failures" v-else :key="idx">
  {{ failure.test.test }} ({{ removeNewLines(failure.test.extra) }})
  <span v-for="(cfg, idxc) in failure.configs" :key="idxc">    [{{ cfg.io_envs}}] {{ cfg.arguments }}
  </span></span>
<span v-if="hasLength(rd.test_todo_passed)">
Test todo-passed:<span v-for="(todo, idx) in rd.test_todo_passed" :key="idx">
  {{ todo.test.test }} ({{ removeNewLines(todo.test.extra) }})
  <span v-for="(cfg, idxc) in todo.configs" :key="idxc">    [{{ cfg.io_envs}}] {{ cfg.arguments }}
</span></span></span>
Compiler messages:<span v-if="!hasLength(rd.compiler_msgs)">
    None.</span><span v-else>
    {{ rd.compiler_msgs }}</span>
</pre>

<hr>
<pre>
About this smoke:
    smoking-perl: {{ rd.smoke_perl }}
  smoker-version: {{ rd.smoke_version }}/{{ rd.smoker_version }}
       timestamp: {{ rd.smoke_date }}
          tester: {{ rd.username }}
</pre>
<div v-if="hasLength(rd.user_note)" class="user-note">
{{ rd.user_note }}
</div>

<div class="report-footer">
  Report generated by {{ webName}} {{ webVersion }} / API {{ appVersion }}
</div>

</div></div>
<div v-else-if="httpError" class="report-not-found">
Report {{ reportId }} not found.
</div>
</template>

<script>
import { mapActions, mapGetters } from "vuex";
import { useRouter }              from 'vue-router';

import { hasLength } from '@/helpers';
import { logDebug } from '@/helpers/logging';
import { summaryClass } from '@/helpers/css';

export default {
  name: "FullReport",
  props: {
     reportId: {
      type: String,
      default: null,
    },
  },
  setup() {
    const router = useRouter()
    const openFile = function (type, id) {
      const fileType = type === 'log_file' ? 'log_file' : 'out_file';
      const reportId = parseInt(id);
      logDebug(`openFile(${fileType}) for ${reportId}`);

      router.push({path: `/file/${fileType}/${reportId}`});
    };
    return { hasLength, summaryClass, openFile };
  },

  data() {
    return {
      show: false,
      httpError: false,
      isLoading: true,
      webVersion: import.meta.env.VITE_APP_VERSION,
      webName:    import.meta.env.VITE_APP_NAME,
    };
  },
  computed: {
    ...mapGetters({
      hasFullReport: "getFullReport/hasFullReport",
      rd:            "getFullReport/reportData",
      hasVersion: "getVersion/hasVersion",
      appVersion: "getVersion/theVersion",
    }),
  },
  mounted() {
    if (!this.hasFullReport || this.rd.id != this.reportId) {
      this.getFullSmokeReportNow(this.reportId);
    }
    else {
      this.isLoading = false;
    }
    if (!this.hasVersion) { this.getVersionNow() }
  },
  methods: {
    ...mapActions({
      getFullReport: "getFullReport/getFullReport",
      getVersion: "getVersion/getVersion",
    }),
    async getFullSmokeReportNow(reportId) {
      this.isLoading = true;
      this.httpError = false;
      try {
        await this.getFullReport(reportId);
      } catch(e) {
        this.httpError = true;
        console.log(`HTTP-Error: ${JSON.stringify(e)}`);
      };
      logDebug(`getFullSmokeReportNow: ${JSON.stringify(this.rd)}`);
      this.isLoading = false;
    },
    async getVersionNow() {
      try {
        await this.getVersion();
      }
      catch(e) {
        console.log(`HTTP-Error: ${e}`);
      }
    },
    removeNewLines(str) {
      if (typeof str === "undefined" ) { return ""; }
      return str.replace(/\n/g, " ");
    },

  },
};
</script>
